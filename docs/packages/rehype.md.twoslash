{
  "version": 1,
  "fileHash": "0ab3368779e3bb15afc0da9c97e4577f7a3ba0d608f4fb31be75ee7c34400cef",
  "cache": {
    "teojfmu_VVDND9IjD9xcgqoGUXo2btP4q2ZCFuTG5Ro:ts:8f03c3e621309cd07e6bf9674cb312c2bf543fccffb30a95cdcbfc462e853ada": {
      "nodes": [
        {
          "type": "hover",
          "text": "(alias) const rehypeShiki: Plugin<[RehypeShikiOptions], Root>\nimport rehypeShiki",
          "start": 7,
          "length": 11,
          "target": "rehypeShiki",
          "line": 0,
          "character": 7
        },
        {
          "type": "hover",
          "text": "(alias) const rehypeStringify: Plugin<[(Options | null | undefined)?], Root, string>\nimport rehypeStringify",
          "docs": "Plugin to add support for serializing as HTML.",
          "tags": [
            [
              "this",
              "  processor."
            ],
            [
              "param",
              "Configuration (optional)."
            ],
            [
              "returns",
              "  Nothing."
            ]
          ],
          "start": 49,
          "length": 15,
          "target": "rehypeStringify",
          "line": 1,
          "character": 7
        },
        {
          "type": "hover",
          "text": "(alias) const remarkParse: Plugin<[(Readonly<Options> | null | undefined)?], string, Root>\nimport remarkParse",
          "docs": "Add support for parsing from markdown.",
          "tags": [
            [
              "this",
              "  processor."
            ],
            [
              "param",
              "Configuration (optional)."
            ],
            [
              "returns",
              "  Nothing."
            ]
          ],
          "start": 96,
          "length": 11,
          "target": "remarkParse",
          "line": 2,
          "character": 7
        },
        {
          "type": "hover",
          "text": "(alias) function remarkRehype(processor: Processor, options?: Readonly<Options> | null | undefined): TransformBridge (+2 overloads)\nimport remarkRehype",
          "docs": "Turn markdown into HTML.\n\n##### Notes\n\n###### Signature\n\n* if a processor is given,\n  runs the (rehype) plugins used on it with a hast tree,\n  then discards the result (*bridge mode*)\n* otherwise,\n  returns a hast tree,\n  the plugins used after `remarkRehype` are rehype plugins (*mutate mode*)\n\n> ðŸ‘‰ **Note**:\n> Itâ€™s highly unlikely that you want to pass a `processor`.\n\n###### HTML\n\nRaw HTML is available in mdast as `html` nodes and can be embedded in hast\nas semistandard `raw` nodes.\nMost plugins ignore `raw` nodes but two notable ones donâ€™t:\n\n* `rehype-stringify` also has an option `allowDangerousHtml` which will\n  output the raw HTML.\n  This is typically discouraged as noted by the option name but is useful if\n  you completely trust authors\n* `rehype-raw` can handle the raw embedded HTML strings by parsing them\n  into standard hast nodes (`element`, `text`, etc);\n  this is a heavy task as it needs a full HTML parser,\n  but it is the only way to support untrusted content\n\n###### Footnotes\n\nMany options supported here relate to footnotes.\nFootnotes are not specified by CommonMark,\nwhich we follow by default.\nThey are supported by GitHub,\nso footnotes can be enabled in markdown with `remark-gfm`.\n\nThe options `footnoteBackLabel` and `footnoteLabel` define natural language\nthat explains footnotes,\nwhich is hidden for sighted users but shown to assistive technology.\nWhen your page is not in English,\nyou must define translated values.\n\nBack references use ARIA attributes,\nbut the section label itself uses a heading that is hidden with an\n`sr-only` class.\nTo show it to sighted users,\ndefine different attributes in `footnoteLabelProperties`.\n\n###### Clobbering\n\nFootnotes introduces a problem,\nas it links footnote calls to footnote definitions on the page through `id`\nattributes generated from user content,\nwhich results in DOM clobbering.\n\nDOM clobbering is this:\n\n```html\n<p id=x></p>\n<script>alert(x) // `x` now refers to the DOM `p#x` element</script>\n```\n\nElements by their ID are made available by browsers on the `window` object,\nwhich is a security risk.\nUsing a prefix solves this problem.\n\nMore information on how to handle clobbering and the prefix is explained in\n*Example: headings (DOM clobbering)* in `rehype-sanitize`.\n\n###### Unknown nodes\n\nUnknown nodes are nodes with a type that isnâ€™t in `handlers` or `passThrough`.\nThe default behavior for unknown nodes is:\n\n* when the node has a `value`\n  (and doesnâ€™t have `data.hName`, `data.hProperties`, or `data.hChildren`,\n  see later),\n  create a hast `text` node\n* otherwise,\n  create a `<div>` element (which could be changed with `data.hName`),\n  with its children mapped from mdast to hast as well\n\nThis behavior can be changed by passing an `unknownHandler`.",
          "tags": [
            [
              "overload",
              null
            ],
            [
              "overload",
              null
            ],
            [
              "overload",
              null
            ],
            [
              "param",
              "destination Processor or configuration (optional)."
            ],
            [
              "param",
              "options When a processor was given,\nconfiguration (optional)."
            ],
            [
              "returns",
              "Transform."
            ]
          ],
          "start": 135,
          "length": 12,
          "target": "remarkRehype",
          "line": 3,
          "character": 7
        },
        {
          "type": "hover",
          "text": "(alias) const unified: Processor<undefined, undefined, undefined, undefined, undefined>\nimport unified",
          "docs": "Create a new processor.",
          "tags": [
            [
              "example",
              "  This example shows how a new processor can be created (from `remark`) and linked\n  to **stdin**(4) and **stdout**(4).\n\n  ```js\n  import process from 'node:process'\n  import concatStream from 'concat-stream'\n  import {remark} from 'remark'\n\n  process.stdin.pipe(\n    concatStream(function (buf) {\n      process.stdout.write(String(remark().processSync(buf)))\n    })\n  )\n  ```"
            ],
            [
              "returns",
              "  New *unfrozen* processor (`processor`).\n\n  This processor is configured to work the same as its ancestor.\n  When the descendant processor is configured in the future it does not\n  affect the ancestral processor."
            ]
          ],
          "start": 178,
          "length": 7,
          "target": "unified",
          "line": 4,
          "character": 9
        },
        {
          "type": "hover",
          "text": "const file: VFile",
          "start": 210,
          "length": 4,
          "target": "file",
          "line": 6,
          "character": 6
        },
        {
          "type": "hover",
          "text": "(alias) unified(): Processor<undefined, undefined, undefined, undefined, undefined>\nimport unified",
          "docs": "Create a new processor.",
          "tags": [
            [
              "example",
              "  This example shows how a new processor can be created (from `remark`) and linked\n  to **stdin**(4) and **stdout**(4).\n\n  ```js\n  import process from 'node:process'\n  import concatStream from 'concat-stream'\n  import {remark} from 'remark'\n\n  process.stdin.pipe(\n    concatStream(function (buf) {\n      process.stdout.write(String(remark().processSync(buf)))\n    })\n  )\n  ```"
            ],
            [
              "returns",
              "  New *unfrozen* processor (`processor`).\n\n  This processor is configured to work the same as its ancestor.\n  When the descendant processor is configured in the future it does not\n  affect the ancestral processor."
            ]
          ],
          "start": 223,
          "length": 7,
          "target": "unified",
          "line": 6,
          "character": 19
        },
        {
          "type": "hover",
          "text": "(method) Processor<undefined, undefined, undefined, undefined, undefined>.use<[], string, Root>(plugin: Plugin<[], string, Root>, ...parameters: [] | [boolean]): Processor<Root, undefined, undefined, undefined, undefined> (+2 overloads)",
          "docs": "Configure the processor to use a plugin, a list of usable values, or a\npreset.\n\nIf the processor is already using a plugin, the previous plugin\nconfiguration is changed based on the options that are passed in.\nIn other words, the plugin is not added a second time.\n\n> **Note**: `use` cannot be called on *frozen* processors.\n> Call the processor first to create a new unfrozen processor.",
          "tags": [
            [
              "example",
              "  There are many ways to pass plugins to `.use()`.\n  This example gives an overview:\n\n  ```js\n  import {unified} from 'unified'\n\n  unified()\n    // Plugin with options:\n    .use(pluginA, {x: true, y: true})\n    // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):\n    .use(pluginA, {y: false, z: true})\n    // Plugins:\n    .use([pluginB, pluginC])\n    // Two plugins, the second with options:\n    .use([pluginD, [pluginE, {}]])\n    // Preset with plugins and settings:\n    .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})\n    // Settings only:\n    .use({settings: {position: false}})\n  ```"
            ],
            [
              "template",
              "{Array<unknown>} [Parameters=[]]"
            ],
            [
              "template",
              "{Node | string | undefined} [Input=undefined]"
            ],
            [
              "template",
              "[Output=Input]"
            ],
            [
              "overload",
              null
            ],
            [
              "overload",
              null
            ],
            [
              "overload",
              null
            ],
            [
              "param",
              "value Usable value."
            ],
            [
              "param",
              "parameters Parameters, when a plugin is given as a usable value."
            ],
            [
              "returns",
              "Current processor."
            ]
          ],
          "start": 236,
          "length": 3,
          "target": "use",
          "line": 7,
          "character": 3
        },
        {
          "type": "hover",
          "text": "(alias) const remarkParse: Plugin<[(Readonly<Options> | null | undefined)?], string, Root>\nimport remarkParse",
          "docs": "Add support for parsing from markdown.",
          "tags": [
            [
              "this",
              "  processor."
            ],
            [
              "param",
              "Configuration (optional)."
            ],
            [
              "returns",
              "  Nothing."
            ]
          ],
          "start": 240,
          "length": 11,
          "target": "remarkParse",
          "line": 7,
          "character": 7
        },
        {
          "type": "hover",
          "text": "(method) Processor<Root, undefined, undefined, undefined, undefined>.use<[], Root, Root>(plugin: Plugin<[], Root, Root>, ...parameters: [] | [boolean]): Processor<Root, Root, Root, undefined, undefined> (+2 overloads)",
          "docs": "Configure the processor to use a plugin, a list of usable values, or a\npreset.\n\nIf the processor is already using a plugin, the previous plugin\nconfiguration is changed based on the options that are passed in.\nIn other words, the plugin is not added a second time.\n\n> **Note**: `use` cannot be called on *frozen* processors.\n> Call the processor first to create a new unfrozen processor.",
          "tags": [
            [
              "example",
              "  There are many ways to pass plugins to `.use()`.\n  This example gives an overview:\n\n  ```js\n  import {unified} from 'unified'\n\n  unified()\n    // Plugin with options:\n    .use(pluginA, {x: true, y: true})\n    // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):\n    .use(pluginA, {y: false, z: true})\n    // Plugins:\n    .use([pluginB, pluginC])\n    // Two plugins, the second with options:\n    .use([pluginD, [pluginE, {}]])\n    // Preset with plugins and settings:\n    .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})\n    // Settings only:\n    .use({settings: {position: false}})\n  ```"
            ],
            [
              "template",
              "{Array<unknown>} [Parameters=[]]"
            ],
            [
              "template",
              "{Node | string | undefined} [Input=undefined]"
            ],
            [
              "template",
              "[Output=Input]"
            ],
            [
              "overload",
              null
            ],
            [
              "overload",
              null
            ],
            [
              "overload",
              null
            ],
            [
              "param",
              "value Usable value."
            ],
            [
              "param",
              "parameters Parameters, when a plugin is given as a usable value."
            ],
            [
              "returns",
              "Current processor."
            ]
          ],
          "start": 256,
          "length": 3,
          "target": "use",
          "line": 8,
          "character": 3
        },
        {
          "type": "hover",
          "text": "(alias) function remarkRehype(processor: Processor, options?: Readonly<Options> | null | undefined): TransformBridge (+2 overloads)\nimport remarkRehype",
          "docs": "Turn markdown into HTML.\n\n##### Notes\n\n###### Signature\n\n* if a processor is given,\n  runs the (rehype) plugins used on it with a hast tree,\n  then discards the result (*bridge mode*)\n* otherwise,\n  returns a hast tree,\n  the plugins used after `remarkRehype` are rehype plugins (*mutate mode*)\n\n> ðŸ‘‰ **Note**:\n> Itâ€™s highly unlikely that you want to pass a `processor`.\n\n###### HTML\n\nRaw HTML is available in mdast as `html` nodes and can be embedded in hast\nas semistandard `raw` nodes.\nMost plugins ignore `raw` nodes but two notable ones donâ€™t:\n\n* `rehype-stringify` also has an option `allowDangerousHtml` which will\n  output the raw HTML.\n  This is typically discouraged as noted by the option name but is useful if\n  you completely trust authors\n* `rehype-raw` can handle the raw embedded HTML strings by parsing them\n  into standard hast nodes (`element`, `text`, etc);\n  this is a heavy task as it needs a full HTML parser,\n  but it is the only way to support untrusted content\n\n###### Footnotes\n\nMany options supported here relate to footnotes.\nFootnotes are not specified by CommonMark,\nwhich we follow by default.\nThey are supported by GitHub,\nso footnotes can be enabled in markdown with `remark-gfm`.\n\nThe options `footnoteBackLabel` and `footnoteLabel` define natural language\nthat explains footnotes,\nwhich is hidden for sighted users but shown to assistive technology.\nWhen your page is not in English,\nyou must define translated values.\n\nBack references use ARIA attributes,\nbut the section label itself uses a heading that is hidden with an\n`sr-only` class.\nTo show it to sighted users,\ndefine different attributes in `footnoteLabelProperties`.\n\n###### Clobbering\n\nFootnotes introduces a problem,\nas it links footnote calls to footnote definitions on the page through `id`\nattributes generated from user content,\nwhich results in DOM clobbering.\n\nDOM clobbering is this:\n\n```html\n<p id=x></p>\n<script>alert(x) // `x` now refers to the DOM `p#x` element</script>\n```\n\nElements by their ID are made available by browsers on the `window` object,\nwhich is a security risk.\nUsing a prefix solves this problem.\n\nMore information on how to handle clobbering and the prefix is explained in\n*Example: headings (DOM clobbering)* in `rehype-sanitize`.\n\n###### Unknown nodes\n\nUnknown nodes are nodes with a type that isnâ€™t in `handlers` or `passThrough`.\nThe default behavior for unknown nodes is:\n\n* when the node has a `value`\n  (and doesnâ€™t have `data.hName`, `data.hProperties`, or `data.hChildren`,\n  see later),\n  create a hast `text` node\n* otherwise,\n  create a `<div>` element (which could be changed with `data.hName`),\n  with its children mapped from mdast to hast as well\n\nThis behavior can be changed by passing an `unknownHandler`.",
          "tags": [
            [
              "overload",
              null
            ],
            [
              "overload",
              null
            ],
            [
              "overload",
              null
            ],
            [
              "param",
              "destination Processor or configuration (optional)."
            ],
            [
              "param",
              "options When a processor was given,\nconfiguration (optional)."
            ],
            [
              "returns",
              "Transform."
            ]
          ],
          "start": 260,
          "length": 12,
          "target": "remarkRehype",
          "line": 8,
          "character": 7
        },
        {
          "type": "hover",
          "text": "(method) Processor<Root, Root, Root, undefined, undefined>.use<[{\n    themes: {\n        light: string;\n        dark: string;\n    };\n}], Root, Root>(plugin: Plugin<[{\n    themes: {\n        light: string;\n        dark: string;\n    };\n}], Root, Root>, ...parameters: [boolean] | [{\n    themes: {\n        light: string;\n        dark: string;\n    };\n}]): Processor<Root, Root, Root, undefined, undefined> (+2 overloads)",
          "docs": "Configure the processor to use a plugin, a list of usable values, or a\npreset.\n\nIf the processor is already using a plugin, the previous plugin\nconfiguration is changed based on the options that are passed in.\nIn other words, the plugin is not added a second time.\n\n> **Note**: `use` cannot be called on *frozen* processors.\n> Call the processor first to create a new unfrozen processor.",
          "tags": [
            [
              "example",
              "  There are many ways to pass plugins to `.use()`.\n  This example gives an overview:\n\n  ```js\n  import {unified} from 'unified'\n\n  unified()\n    // Plugin with options:\n    .use(pluginA, {x: true, y: true})\n    // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):\n    .use(pluginA, {y: false, z: true})\n    // Plugins:\n    .use([pluginB, pluginC])\n    // Two plugins, the second with options:\n    .use([pluginD, [pluginE, {}]])\n    // Preset with plugins and settings:\n    .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})\n    // Settings only:\n    .use({settings: {position: false}})\n  ```"
            ],
            [
              "template",
              "{Array<unknown>} [Parameters=[]]"
            ],
            [
              "template",
              "{Node | string | undefined} [Input=undefined]"
            ],
            [
              "template",
              "[Output=Input]"
            ],
            [
              "overload",
              null
            ],
            [
              "overload",
              null
            ],
            [
              "overload",
              null
            ],
            [
              "param",
              "value Usable value."
            ],
            [
              "param",
              "parameters Parameters, when a plugin is given as a usable value."
            ],
            [
              "returns",
              "Current processor."
            ]
          ],
          "start": 277,
          "length": 3,
          "target": "use",
          "line": 9,
          "character": 3
        },
        {
          "type": "hover",
          "text": "(alias) const rehypeShiki: Plugin<[RehypeShikiOptions], Root>\nimport rehypeShiki",
          "start": 281,
          "length": 11,
          "target": "rehypeShiki",
          "line": 9,
          "character": 7
        },
        {
          "type": "hover",
          "text": "(property) themes: {\n    light: string;\n    dark: string;\n}",
          "start": 337,
          "length": 6,
          "target": "themes",
          "line": 11,
          "character": 4
        },
        {
          "type": "hover",
          "text": "(property) light: string",
          "start": 353,
          "length": 5,
          "target": "light",
          "line": 12,
          "character": 6
        },
        {
          "type": "hover",
          "text": "(property) dark: string",
          "start": 383,
          "length": 4,
          "target": "dark",
          "line": 13,
          "character": 6
        },
        {
          "type": "hover",
          "text": "(method) Processor<Root, Root, Root, undefined, undefined>.use<[], Root, string>(plugin: Plugin<[], Root, string>, ...parameters: [] | [boolean]): Processor<Root, Root, Root, Root, string> (+2 overloads)",
          "docs": "Configure the processor to use a plugin, a list of usable values, or a\npreset.\n\nIf the processor is already using a plugin, the previous plugin\nconfiguration is changed based on the options that are passed in.\nIn other words, the plugin is not added a second time.\n\n> **Note**: `use` cannot be called on *frozen* processors.\n> Call the processor first to create a new unfrozen processor.",
          "tags": [
            [
              "example",
              "  There are many ways to pass plugins to `.use()`.\n  This example gives an overview:\n\n  ```js\n  import {unified} from 'unified'\n\n  unified()\n    // Plugin with options:\n    .use(pluginA, {x: true, y: true})\n    // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):\n    .use(pluginA, {y: false, z: true})\n    // Plugins:\n    .use([pluginB, pluginC])\n    // Two plugins, the second with options:\n    .use([pluginD, [pluginE, {}]])\n    // Preset with plugins and settings:\n    .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})\n    // Settings only:\n    .use({settings: {position: false}})\n  ```"
            ],
            [
              "template",
              "{Array<unknown>} [Parameters=[]]"
            ],
            [
              "template",
              "{Node | string | undefined} [Input=undefined]"
            ],
            [
              "template",
              "[Output=Input]"
            ],
            [
              "overload",
              null
            ],
            [
              "overload",
              null
            ],
            [
              "overload",
              null
            ],
            [
              "param",
              "value Usable value."
            ],
            [
              "param",
              "parameters Parameters, when a plugin is given as a usable value."
            ],
            [
              "returns",
              "Current processor."
            ]
          ],
          "start": 419,
          "length": 3,
          "target": "use",
          "line": 16,
          "character": 3
        },
        {
          "type": "hover",
          "text": "(alias) const rehypeStringify: Plugin<[(Options | null | undefined)?], Root, string>\nimport rehypeStringify",
          "docs": "Plugin to add support for serializing as HTML.",
          "tags": [
            [
              "this",
              "  processor."
            ],
            [
              "param",
              "Configuration (optional)."
            ],
            [
              "returns",
              "  Nothing."
            ]
          ],
          "start": 423,
          "length": 15,
          "target": "rehypeStringify",
          "line": 16,
          "character": 7
        },
        {
          "type": "hover",
          "text": "(method) Processor<Root, Root, Root, Root, string>.process(file?: Compatible | undefined): Promise<VFile> (+1 overload)",
          "docs": "Process the given file as configured on the processor.\n\n> **Note**: `process` freezes the processor if not already *frozen*.\n\n> **Note**: `process` performs the parse, run, and stringify phases.",
          "tags": [
            [
              "overload",
              null
            ],
            [
              "overload",
              null
            ],
            [
              "param",
              "file File (optional); typically `string` or `VFile`]; any value accepted as\n`x` in `new VFile(x)`."
            ],
            [
              "param",
              "done Callback (optional)."
            ],
            [
              "returns",
              "\nNothing if `done` is given.\nOtherwise a promise, rejected with a fatal error or resolved with the\nprocessed file.\n\nThe parsed, transformed, and compiled value is available at\n`file.value` (see note).\n\n> **Note**: unified typically compiles by serializing: most\n> compilers return `string` (or `Uint8Array`).\n> Some compilers, such as the one configured with\n> [`rehype-react`][rehype-react], return other values (in this case, a\n> React tree).\n> If youâ€™re using a compiler that doesnâ€™t serialize, expect different\n> result values.\n>\n> To register custom results in TypeScript, add them to\n> {@linkcode CompileResultMap}.\n\n[rehype-react]: https://github.com/rehypejs/rehype-react"
            ]
          ],
          "start": 443,
          "length": 7,
          "target": "process",
          "line": 17,
          "character": 3
        },
        {
          "type": "hover",
          "text": "any",
          "start": 457,
          "length": 2,
          "target": "fs",
          "line": 17,
          "character": 17
        },
        {
          "type": "hover",
          "text": "any",
          "start": 460,
          "length": 8,
          "target": "readFile",
          "line": 17,
          "character": 20
        }
      ],
      "code": "import rehypeShiki from '@shikijs/rehype'\nimport rehypeStringify from 'rehype-stringify'\nimport remarkParse from 'remark-parse'\nimport remarkRehype from 'remark-rehype'\nimport { unified } from 'unified'\n\nconst file = await unified()\n  .use(remarkParse)\n  .use(remarkRehype)\n  .use(rehypeShiki, {\n    // or `theme` for a single theme\n    themes: {\n      light: 'vitesse-light',\n      dark: 'vitesse-dark',\n    }\n  })\n  .use(rehypeStringify)\n  .process(await fs.readFile('./input.md'))",
      "meta": {
        "extension": "ts"
      }
    },
    "teojfmu_VVDND9IjD9xcgqoGUXo2btP4q2ZCFuTG5Ro:ts:a1a2beb02d21c529522a07195c2b22b6b4829066be80aaa78af5aca8111b1b62": {
      "nodes": [
        {
          "type": "hover",
          "text": "(alias) function rehypeShikiFromHighlighter(highlighter: HighlighterGeneric<any, any>, options: RehypeShikiCoreOptions): Transformer<Root, Root>\nimport rehypeShikiFromHighlighter",
          "start": 7,
          "length": 26,
          "target": "rehypeShikiFromHighlighter",
          "line": 0,
          "character": 7
        },
        {
          "type": "hover",
          "text": "(alias) const rehypeStringify: Plugin<[(Options | null | undefined)?], Root, string>\nimport rehypeStringify",
          "docs": "Plugin to add support for serializing as HTML.",
          "tags": [
            [
              "this",
              "  processor."
            ],
            [
              "param",
              "Configuration (optional)."
            ],
            [
              "returns",
              "  Nothing."
            ]
          ],
          "start": 69,
          "length": 15,
          "target": "rehypeStringify",
          "line": 1,
          "character": 7
        },
        {
          "type": "hover",
          "text": "(alias) const remarkParse: Plugin<[(Readonly<Options> | null | undefined)?], string, Root>\nimport remarkParse",
          "docs": "Add support for parsing from markdown.",
          "tags": [
            [
              "this",
              "  processor."
            ],
            [
              "param",
              "Configuration (optional)."
            ],
            [
              "returns",
              "  Nothing."
            ]
          ],
          "start": 116,
          "length": 11,
          "target": "remarkParse",
          "line": 2,
          "character": 7
        },
        {
          "type": "hover",
          "text": "(alias) function remarkRehype(processor: Processor, options?: Readonly<Options> | null | undefined): TransformBridge (+2 overloads)\nimport remarkRehype",
          "docs": "Turn markdown into HTML.\n\n##### Notes\n\n###### Signature\n\n* if a processor is given,\n  runs the (rehype) plugins used on it with a hast tree,\n  then discards the result (*bridge mode*)\n* otherwise,\n  returns a hast tree,\n  the plugins used after `remarkRehype` are rehype plugins (*mutate mode*)\n\n> ðŸ‘‰ **Note**:\n> Itâ€™s highly unlikely that you want to pass a `processor`.\n\n###### HTML\n\nRaw HTML is available in mdast as `html` nodes and can be embedded in hast\nas semistandard `raw` nodes.\nMost plugins ignore `raw` nodes but two notable ones donâ€™t:\n\n* `rehype-stringify` also has an option `allowDangerousHtml` which will\n  output the raw HTML.\n  This is typically discouraged as noted by the option name but is useful if\n  you completely trust authors\n* `rehype-raw` can handle the raw embedded HTML strings by parsing them\n  into standard hast nodes (`element`, `text`, etc);\n  this is a heavy task as it needs a full HTML parser,\n  but it is the only way to support untrusted content\n\n###### Footnotes\n\nMany options supported here relate to footnotes.\nFootnotes are not specified by CommonMark,\nwhich we follow by default.\nThey are supported by GitHub,\nso footnotes can be enabled in markdown with `remark-gfm`.\n\nThe options `footnoteBackLabel` and `footnoteLabel` define natural language\nthat explains footnotes,\nwhich is hidden for sighted users but shown to assistive technology.\nWhen your page is not in English,\nyou must define translated values.\n\nBack references use ARIA attributes,\nbut the section label itself uses a heading that is hidden with an\n`sr-only` class.\nTo show it to sighted users,\ndefine different attributes in `footnoteLabelProperties`.\n\n###### Clobbering\n\nFootnotes introduces a problem,\nas it links footnote calls to footnote definitions on the page through `id`\nattributes generated from user content,\nwhich results in DOM clobbering.\n\nDOM clobbering is this:\n\n```html\n<p id=x></p>\n<script>alert(x) // `x` now refers to the DOM `p#x` element</script>\n```\n\nElements by their ID are made available by browsers on the `window` object,\nwhich is a security risk.\nUsing a prefix solves this problem.\n\nMore information on how to handle clobbering and the prefix is explained in\n*Example: headings (DOM clobbering)* in `rehype-sanitize`.\n\n###### Unknown nodes\n\nUnknown nodes are nodes with a type that isnâ€™t in `handlers` or `passThrough`.\nThe default behavior for unknown nodes is:\n\n* when the node has a `value`\n  (and doesnâ€™t have `data.hName`, `data.hProperties`, or `data.hChildren`,\n  see later),\n  create a hast `text` node\n* otherwise,\n  create a `<div>` element (which could be changed with `data.hName`),\n  with its children mapped from mdast to hast as well\n\nThis behavior can be changed by passing an `unknownHandler`.",
          "tags": [
            [
              "overload",
              null
            ],
            [
              "overload",
              null
            ],
            [
              "overload",
              null
            ],
            [
              "param",
              "destination Processor or configuration (optional)."
            ],
            [
              "param",
              "options When a processor was given,\nconfiguration (optional)."
            ],
            [
              "returns",
              "Transform."
            ]
          ],
          "start": 155,
          "length": 12,
          "target": "remarkRehype",
          "line": 3,
          "character": 7
        },
        {
          "type": "hover",
          "text": "(alias) function createHighlighterCore(options: HighlighterCoreOptions<false>): Promise<HighlighterCore>\nimport createHighlighterCore",
          "docs": "Create a Shiki core highlighter instance, with no languages or themes bundled.\nWasm and each language and theme must be loaded manually.",
          "tags": [
            [
              "see",
              "http://shiki.style/guide/bundles#fine-grained-bundle"
            ]
          ],
          "start": 198,
          "length": 21,
          "target": "createHighlighterCore",
          "line": 4,
          "character": 9
        },
        {
          "type": "hover",
          "text": "(alias) function createOnigurumaEngine(options?: LoadWasmOptions | null): Promise<RegexEngine>\nimport createOnigurumaEngine",
          "start": 249,
          "length": 21,
          "target": "createOnigurumaEngine",
          "line": 5,
          "character": 9
        },
        {
          "type": "hover",
          "text": "(alias) const unified: Processor<undefined, undefined, undefined, undefined, undefined>\nimport unified",
          "docs": "Create a new processor.",
          "tags": [
            [
              "example",
              "  This example shows how a new processor can be created (from `remark`) and linked\n  to **stdin**(4) and **stdout**(4).\n\n  ```js\n  import process from 'node:process'\n  import concatStream from 'concat-stream'\n  import {remark} from 'remark'\n\n  process.stdin.pipe(\n    concatStream(function (buf) {\n      process.stdout.write(String(remark().processSync(buf)))\n    })\n  )\n  ```"
            ],
            [
              "returns",
              "  New *unfrozen* processor (`processor`).\n\n  This processor is configured to work the same as its ancestor.\n  When the descendant processor is configured in the future it does not\n  affect the ancestral processor."
            ]
          ],
          "start": 313,
          "length": 7,
          "target": "unified",
          "line": 7,
          "character": 9
        },
        {
          "type": "hover",
          "text": "const highlighter: HighlighterCore",
          "start": 345,
          "length": 11,
          "target": "highlighter",
          "line": 9,
          "character": 6
        },
        {
          "type": "hover",
          "text": "(alias) createHighlighterCore(options: HighlighterCoreOptions<false>): Promise<HighlighterCore>\nimport createHighlighterCore",
          "docs": "Create a Shiki core highlighter instance, with no languages or themes bundled.\nWasm and each language and theme must be loaded manually.",
          "tags": [
            [
              "see",
              "http://shiki.style/guide/bundles#fine-grained-bundle"
            ]
          ],
          "start": 365,
          "length": 21,
          "target": "createHighlighterCore",
          "line": 9,
          "character": 26
        },
        {
          "type": "hover",
          "text": "(property) HighlighterCoreOptions<false>.themes?: ThemeInput[] | undefined",
          "docs": "Theme names, or theme registration objects to be loaded upfront.",
          "start": 391,
          "length": 6,
          "target": "themes",
          "line": 10,
          "character": 2
        },
        {
          "type": "hover",
          "text": "(property) HighlighterCoreOptions<false>.langs?: LanguageInput[] | undefined",
          "docs": "Language names, or language registration objects to be loaded upfront.",
          "start": 452,
          "length": 5,
          "target": "langs",
          "line": 13,
          "character": 2
        },
        {
          "type": "hover",
          "text": "(property) HighlighterCoreOptions<false>.engine: Awaitable<RegexEngine>",
          "docs": "Custom RegExp engine.",
          "start": 509,
          "length": 6,
          "target": "engine",
          "line": 16,
          "character": 2
        },
        {
          "type": "hover",
          "text": "(alias) createOnigurumaEngine(options?: LoadWasmOptions | null): Promise<RegexEngine>\nimport createOnigurumaEngine",
          "start": 517,
          "length": 21,
          "target": "createOnigurumaEngine",
          "line": 16,
          "character": 10
        },
        {
          "type": "hover",
          "text": "const raw: any",
          "start": 577,
          "length": 3,
          "target": "raw",
          "line": 19,
          "character": 6
        },
        {
          "type": "hover",
          "text": "any",
          "start": 589,
          "length": 2,
          "target": "fs",
          "line": 19,
          "character": 18
        },
        {
          "type": "hover",
          "text": "any",
          "start": 592,
          "length": 8,
          "target": "readFile",
          "line": 19,
          "character": 21
        },
        {
          "type": "hover",
          "text": "const file: VFile",
          "start": 621,
          "length": 4,
          "target": "file",
          "line": 20,
          "character": 6
        },
        {
          "type": "hover",
          "text": "(alias) unified(): Processor<undefined, undefined, undefined, undefined, undefined>\nimport unified",
          "docs": "Create a new processor.",
          "tags": [
            [
              "example",
              "  This example shows how a new processor can be created (from `remark`) and linked\n  to **stdin**(4) and **stdout**(4).\n\n  ```js\n  import process from 'node:process'\n  import concatStream from 'concat-stream'\n  import {remark} from 'remark'\n\n  process.stdin.pipe(\n    concatStream(function (buf) {\n      process.stdout.write(String(remark().processSync(buf)))\n    })\n  )\n  ```"
            ],
            [
              "returns",
              "  New *unfrozen* processor (`processor`).\n\n  This processor is configured to work the same as its ancestor.\n  When the descendant processor is configured in the future it does not\n  affect the ancestral processor."
            ]
          ],
          "start": 634,
          "length": 7,
          "target": "unified",
          "line": 20,
          "character": 19
        },
        {
          "type": "hover",
          "text": "(method) Processor<undefined, undefined, undefined, undefined, undefined>.use<[], string, Root>(plugin: Plugin<[], string, Root>, ...parameters: [] | [boolean]): Processor<Root, undefined, undefined, undefined, undefined> (+2 overloads)",
          "docs": "Configure the processor to use a plugin, a list of usable values, or a\npreset.\n\nIf the processor is already using a plugin, the previous plugin\nconfiguration is changed based on the options that are passed in.\nIn other words, the plugin is not added a second time.\n\n> **Note**: `use` cannot be called on *frozen* processors.\n> Call the processor first to create a new unfrozen processor.",
          "tags": [
            [
              "example",
              "  There are many ways to pass plugins to `.use()`.\n  This example gives an overview:\n\n  ```js\n  import {unified} from 'unified'\n\n  unified()\n    // Plugin with options:\n    .use(pluginA, {x: true, y: true})\n    // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):\n    .use(pluginA, {y: false, z: true})\n    // Plugins:\n    .use([pluginB, pluginC])\n    // Two plugins, the second with options:\n    .use([pluginD, [pluginE, {}]])\n    // Preset with plugins and settings:\n    .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})\n    // Settings only:\n    .use({settings: {position: false}})\n  ```"
            ],
            [
              "template",
              "{Array<unknown>} [Parameters=[]]"
            ],
            [
              "template",
              "{Node | string | undefined} [Input=undefined]"
            ],
            [
              "template",
              "[Output=Input]"
            ],
            [
              "overload",
              null
            ],
            [
              "overload",
              null
            ],
            [
              "overload",
              null
            ],
            [
              "param",
              "value Usable value."
            ],
            [
              "param",
              "parameters Parameters, when a plugin is given as a usable value."
            ],
            [
              "returns",
              "Current processor."
            ]
          ],
          "start": 647,
          "length": 3,
          "target": "use",
          "line": 21,
          "character": 3
        },
        {
          "type": "hover",
          "text": "(alias) const remarkParse: Plugin<[(Readonly<Options> | null | undefined)?], string, Root>\nimport remarkParse",
          "docs": "Add support for parsing from markdown.",
          "tags": [
            [
              "this",
              "  processor."
            ],
            [
              "param",
              "Configuration (optional)."
            ],
            [
              "returns",
              "  Nothing."
            ]
          ],
          "start": 651,
          "length": 11,
          "target": "remarkParse",
          "line": 21,
          "character": 7
        },
        {
          "type": "hover",
          "text": "(method) Processor<Root, undefined, undefined, undefined, undefined>.use<[], Root, Root>(plugin: Plugin<[], Root, Root>, ...parameters: [] | [boolean]): Processor<Root, Root, Root, undefined, undefined> (+2 overloads)",
          "docs": "Configure the processor to use a plugin, a list of usable values, or a\npreset.\n\nIf the processor is already using a plugin, the previous plugin\nconfiguration is changed based on the options that are passed in.\nIn other words, the plugin is not added a second time.\n\n> **Note**: `use` cannot be called on *frozen* processors.\n> Call the processor first to create a new unfrozen processor.",
          "tags": [
            [
              "example",
              "  There are many ways to pass plugins to `.use()`.\n  This example gives an overview:\n\n  ```js\n  import {unified} from 'unified'\n\n  unified()\n    // Plugin with options:\n    .use(pluginA, {x: true, y: true})\n    // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):\n    .use(pluginA, {y: false, z: true})\n    // Plugins:\n    .use([pluginB, pluginC])\n    // Two plugins, the second with options:\n    .use([pluginD, [pluginE, {}]])\n    // Preset with plugins and settings:\n    .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})\n    // Settings only:\n    .use({settings: {position: false}})\n  ```"
            ],
            [
              "template",
              "{Array<unknown>} [Parameters=[]]"
            ],
            [
              "template",
              "{Node | string | undefined} [Input=undefined]"
            ],
            [
              "template",
              "[Output=Input]"
            ],
            [
              "overload",
              null
            ],
            [
              "overload",
              null
            ],
            [
              "overload",
              null
            ],
            [
              "param",
              "value Usable value."
            ],
            [
              "param",
              "parameters Parameters, when a plugin is given as a usable value."
            ],
            [
              "returns",
              "Current processor."
            ]
          ],
          "start": 667,
          "length": 3,
          "target": "use",
          "line": 22,
          "character": 3
        },
        {
          "type": "hover",
          "text": "(alias) function remarkRehype(processor: Processor, options?: Readonly<Options> | null | undefined): TransformBridge (+2 overloads)\nimport remarkRehype",
          "docs": "Turn markdown into HTML.\n\n##### Notes\n\n###### Signature\n\n* if a processor is given,\n  runs the (rehype) plugins used on it with a hast tree,\n  then discards the result (*bridge mode*)\n* otherwise,\n  returns a hast tree,\n  the plugins used after `remarkRehype` are rehype plugins (*mutate mode*)\n\n> ðŸ‘‰ **Note**:\n> Itâ€™s highly unlikely that you want to pass a `processor`.\n\n###### HTML\n\nRaw HTML is available in mdast as `html` nodes and can be embedded in hast\nas semistandard `raw` nodes.\nMost plugins ignore `raw` nodes but two notable ones donâ€™t:\n\n* `rehype-stringify` also has an option `allowDangerousHtml` which will\n  output the raw HTML.\n  This is typically discouraged as noted by the option name but is useful if\n  you completely trust authors\n* `rehype-raw` can handle the raw embedded HTML strings by parsing them\n  into standard hast nodes (`element`, `text`, etc);\n  this is a heavy task as it needs a full HTML parser,\n  but it is the only way to support untrusted content\n\n###### Footnotes\n\nMany options supported here relate to footnotes.\nFootnotes are not specified by CommonMark,\nwhich we follow by default.\nThey are supported by GitHub,\nso footnotes can be enabled in markdown with `remark-gfm`.\n\nThe options `footnoteBackLabel` and `footnoteLabel` define natural language\nthat explains footnotes,\nwhich is hidden for sighted users but shown to assistive technology.\nWhen your page is not in English,\nyou must define translated values.\n\nBack references use ARIA attributes,\nbut the section label itself uses a heading that is hidden with an\n`sr-only` class.\nTo show it to sighted users,\ndefine different attributes in `footnoteLabelProperties`.\n\n###### Clobbering\n\nFootnotes introduces a problem,\nas it links footnote calls to footnote definitions on the page through `id`\nattributes generated from user content,\nwhich results in DOM clobbering.\n\nDOM clobbering is this:\n\n```html\n<p id=x></p>\n<script>alert(x) // `x` now refers to the DOM `p#x` element</script>\n```\n\nElements by their ID are made available by browsers on the `window` object,\nwhich is a security risk.\nUsing a prefix solves this problem.\n\nMore information on how to handle clobbering and the prefix is explained in\n*Example: headings (DOM clobbering)* in `rehype-sanitize`.\n\n###### Unknown nodes\n\nUnknown nodes are nodes with a type that isnâ€™t in `handlers` or `passThrough`.\nThe default behavior for unknown nodes is:\n\n* when the node has a `value`\n  (and doesnâ€™t have `data.hName`, `data.hProperties`, or `data.hChildren`,\n  see later),\n  create a hast `text` node\n* otherwise,\n  create a `<div>` element (which could be changed with `data.hName`),\n  with its children mapped from mdast to hast as well\n\nThis behavior can be changed by passing an `unknownHandler`.",
          "tags": [
            [
              "overload",
              null
            ],
            [
              "overload",
              null
            ],
            [
              "overload",
              null
            ],
            [
              "param",
              "destination Processor or configuration (optional)."
            ],
            [
              "param",
              "options When a processor was given,\nconfiguration (optional)."
            ],
            [
              "returns",
              "Transform."
            ]
          ],
          "start": 671,
          "length": 12,
          "target": "remarkRehype",
          "line": 22,
          "character": 7
        },
        {
          "type": "hover",
          "text": "(method) Processor<Root, Root, Root, undefined, undefined>.use<[highlighter: HighlighterGeneric<any, any>, options: RehypeShikiCoreOptions], Root, Root>(plugin: Plugin<[highlighter: HighlighterGeneric<any, any>, options: RehypeShikiCoreOptions], Root, Root>, ...parameters: [boolean] | [highlighter: HighlighterGeneric<any, any>, options: RehypeShikiCoreOptions]): Processor<Root, Root, Root, undefined, undefined> (+2 overloads)",
          "docs": "Configure the processor to use a plugin, a list of usable values, or a\npreset.\n\nIf the processor is already using a plugin, the previous plugin\nconfiguration is changed based on the options that are passed in.\nIn other words, the plugin is not added a second time.\n\n> **Note**: `use` cannot be called on *frozen* processors.\n> Call the processor first to create a new unfrozen processor.",
          "tags": [
            [
              "example",
              "  There are many ways to pass plugins to `.use()`.\n  This example gives an overview:\n\n  ```js\n  import {unified} from 'unified'\n\n  unified()\n    // Plugin with options:\n    .use(pluginA, {x: true, y: true})\n    // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):\n    .use(pluginA, {y: false, z: true})\n    // Plugins:\n    .use([pluginB, pluginC])\n    // Two plugins, the second with options:\n    .use([pluginD, [pluginE, {}]])\n    // Preset with plugins and settings:\n    .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})\n    // Settings only:\n    .use({settings: {position: false}})\n  ```"
            ],
            [
              "template",
              "{Array<unknown>} [Parameters=[]]"
            ],
            [
              "template",
              "{Node | string | undefined} [Input=undefined]"
            ],
            [
              "template",
              "[Output=Input]"
            ],
            [
              "overload",
              null
            ],
            [
              "overload",
              null
            ],
            [
              "overload",
              null
            ],
            [
              "param",
              "value Usable value."
            ],
            [
              "param",
              "parameters Parameters, when a plugin is given as a usable value."
            ],
            [
              "returns",
              "Current processor."
            ]
          ],
          "start": 688,
          "length": 3,
          "target": "use",
          "line": 23,
          "character": 3
        },
        {
          "type": "hover",
          "text": "(alias) function rehypeShikiFromHighlighter(highlighter: HighlighterGeneric<any, any>, options: RehypeShikiCoreOptions): Transformer<Root, Root>\nimport rehypeShikiFromHighlighter",
          "start": 692,
          "length": 26,
          "target": "rehypeShikiFromHighlighter",
          "line": 23,
          "character": 7
        },
        {
          "type": "hover",
          "text": "const highlighter: HighlighterCore",
          "start": 720,
          "length": 11,
          "target": "highlighter",
          "line": 23,
          "character": 35
        },
        {
          "type": "hover",
          "text": "(property) CodeOptionsMultipleThemes<BundledTheme>.themes: Partial<Record<string, ThemeRegistrationAny | StringLiteralUnion<BundledTheme, string>>>",
          "docs": "A map of color names to themes.\nThis allows you to specify multiple themes for the generated code.\n\n```ts\nhighlighter.codeToHtml(code, {\n  lang: 'js',\n  themes: {\n    light: 'vitesse-light',\n    dark: 'vitesse-dark',\n  }\n})\n```\n\nWill generate:\n\n```html\n<span style=\"color:#111;--shiki-dark:#fff;\">code</span>\n```",
          "tags": [
            [
              "see",
              "https://github.com/shikijs/shiki#lightdark-dual-themes"
            ]
          ],
          "start": 776,
          "length": 6,
          "target": "themes",
          "line": 25,
          "character": 4
        },
        {
          "type": "hover",
          "text": "(property) light: \"vitesse-light\"",
          "start": 792,
          "length": 5,
          "target": "light",
          "line": 26,
          "character": 6
        },
        {
          "type": "hover",
          "text": "(property) dark: \"vitesse-dark\"",
          "start": 822,
          "length": 4,
          "target": "dark",
          "line": 27,
          "character": 6
        },
        {
          "type": "hover",
          "text": "(method) Processor<Root, Root, Root, undefined, undefined>.use<[], Root, string>(plugin: Plugin<[], Root, string>, ...parameters: [] | [boolean]): Processor<Root, Root, Root, Root, string> (+2 overloads)",
          "docs": "Configure the processor to use a plugin, a list of usable values, or a\npreset.\n\nIf the processor is already using a plugin, the previous plugin\nconfiguration is changed based on the options that are passed in.\nIn other words, the plugin is not added a second time.\n\n> **Note**: `use` cannot be called on *frozen* processors.\n> Call the processor first to create a new unfrozen processor.",
          "tags": [
            [
              "example",
              "  There are many ways to pass plugins to `.use()`.\n  This example gives an overview:\n\n  ```js\n  import {unified} from 'unified'\n\n  unified()\n    // Plugin with options:\n    .use(pluginA, {x: true, y: true})\n    // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):\n    .use(pluginA, {y: false, z: true})\n    // Plugins:\n    .use([pluginB, pluginC])\n    // Two plugins, the second with options:\n    .use([pluginD, [pluginE, {}]])\n    // Preset with plugins and settings:\n    .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})\n    // Settings only:\n    .use({settings: {position: false}})\n  ```"
            ],
            [
              "template",
              "{Array<unknown>} [Parameters=[]]"
            ],
            [
              "template",
              "{Node | string | undefined} [Input=undefined]"
            ],
            [
              "template",
              "[Output=Input]"
            ],
            [
              "overload",
              null
            ],
            [
              "overload",
              null
            ],
            [
              "overload",
              null
            ],
            [
              "param",
              "value Usable value."
            ],
            [
              "param",
              "parameters Parameters, when a plugin is given as a usable value."
            ],
            [
              "returns",
              "Current processor."
            ]
          ],
          "start": 858,
          "length": 3,
          "target": "use",
          "line": 30,
          "character": 3
        },
        {
          "type": "hover",
          "text": "(alias) const rehypeStringify: Plugin<[(Options | null | undefined)?], Root, string>\nimport rehypeStringify",
          "docs": "Plugin to add support for serializing as HTML.",
          "tags": [
            [
              "this",
              "  processor."
            ],
            [
              "param",
              "Configuration (optional)."
            ],
            [
              "returns",
              "  Nothing."
            ]
          ],
          "start": 862,
          "length": 15,
          "target": "rehypeStringify",
          "line": 30,
          "character": 7
        },
        {
          "type": "hover",
          "text": "(method) Processor<Root, Root, Root, Root, string>.processSync(file?: Compatible | undefined): VFile",
          "docs": "Process the given file as configured on the processor.\n\nAn error is thrown if asynchronous transforms are configured.\n\n> **Note**: `processSync` freezes the processor if not already *frozen*.\n\n> **Note**: `processSync` performs the parse, run, and stringify phases.",
          "tags": [
            [
              "param",
              "file File (optional); typically `string` or `VFile`; any value accepted as\n`x` in `new VFile(x)`."
            ],
            [
              "returns",
              "\nThe processed file.\n\nThe parsed, transformed, and compiled value is available at\n`file.value` (see note).\n\n> **Note**: unified typically compiles by serializing: most\n> compilers return `string` (or `Uint8Array`).\n> Some compilers, such as the one configured with\n> [`rehype-react`][rehype-react], return other values (in this case, a\n> React tree).\n> If youâ€™re using a compiler that doesnâ€™t serialize, expect different\n> result values.\n>\n> To register custom results in TypeScript, add them to\n> {@linkcode CompileResultMap}.\n\n[rehype-react]: https://github.com/rehypejs/rehype-react"
            ]
          ],
          "start": 882,
          "length": 11,
          "target": "processSync",
          "line": 31,
          "character": 3
        },
        {
          "type": "hover",
          "text": "const raw: any",
          "start": 894,
          "length": 3,
          "target": "raw",
          "line": 31,
          "character": 15
        }
      ],
      "code": "import rehypeShikiFromHighlighter from '@shikijs/rehype/core'\nimport rehypeStringify from 'rehype-stringify'\nimport remarkParse from 'remark-parse'\nimport remarkRehype from 'remark-rehype'\nimport { createHighlighterCore } from 'shiki/core'\nimport { createOnigurumaEngine } from 'shiki/engine/oniguruma'\n\nimport { unified } from 'unified'\n\nconst highlighter = await createHighlighterCore({\n  themes: [\n    import('@shikijs/themes/vitesse-light')\n  ],\n  langs: [\n    import('@shikijs/langs/javascript'),\n  ],\n  engine: createOnigurumaEngine(() => import('shiki/wasm'))\n})\n\nconst raw = await fs.readFile('./input.md')\nconst file = await unified()\n  .use(remarkParse)\n  .use(remarkRehype)\n  .use(rehypeShikiFromHighlighter, highlighter, {\n    // or `theme` for a single theme\n    themes: {\n      light: 'vitesse-light',\n      dark: 'vitesse-dark',\n    }\n  })\n  .use(rehypeStringify)\n  .processSync(raw) // it's also possible to process synchronously",
      "meta": {
        "extension": "ts"
      }
    },
    "teojfmu_VVDND9IjD9xcgqoGUXo2btP4q2ZCFuTG5Ro:ts:2e21193e7cd2744fb7aa8f9774019676aac825ad409766c6d37013c8c20d418c": {
      "nodes": [
        {
          "type": "hover",
          "text": "(alias) const rehypeShiki: Plugin<[RehypeShikiOptions], Root>\nimport rehypeShiki",
          "start": 7,
          "length": 11,
          "target": "rehypeShiki",
          "line": 0,
          "character": 7
        },
        {
          "type": "hover",
          "text": "(alias) const rehypeStringify: Plugin<[(Options | null | undefined)?], Root, string>\nimport rehypeStringify",
          "docs": "Plugin to add support for serializing as HTML.",
          "tags": [
            [
              "this",
              "  processor."
            ],
            [
              "param",
              "Configuration (optional)."
            ],
            [
              "returns",
              "  Nothing."
            ]
          ],
          "start": 49,
          "length": 15,
          "target": "rehypeStringify",
          "line": 1,
          "character": 7
        },
        {
          "type": "hover",
          "text": "(alias) const remarkParse: Plugin<[(Readonly<Options> | null | undefined)?], string, Root>\nimport remarkParse",
          "docs": "Add support for parsing from markdown.",
          "tags": [
            [
              "this",
              "  processor."
            ],
            [
              "param",
              "Configuration (optional)."
            ],
            [
              "returns",
              "  Nothing."
            ]
          ],
          "start": 96,
          "length": 11,
          "target": "remarkParse",
          "line": 2,
          "character": 7
        },
        {
          "type": "hover",
          "text": "(alias) function remarkRehype(processor: Processor, options?: Readonly<Options> | null | undefined): TransformBridge (+2 overloads)\nimport remarkRehype",
          "docs": "Turn markdown into HTML.\n\n##### Notes\n\n###### Signature\n\n* if a processor is given,\n  runs the (rehype) plugins used on it with a hast tree,\n  then discards the result (*bridge mode*)\n* otherwise,\n  returns a hast tree,\n  the plugins used after `remarkRehype` are rehype plugins (*mutate mode*)\n\n> ðŸ‘‰ **Note**:\n> Itâ€™s highly unlikely that you want to pass a `processor`.\n\n###### HTML\n\nRaw HTML is available in mdast as `html` nodes and can be embedded in hast\nas semistandard `raw` nodes.\nMost plugins ignore `raw` nodes but two notable ones donâ€™t:\n\n* `rehype-stringify` also has an option `allowDangerousHtml` which will\n  output the raw HTML.\n  This is typically discouraged as noted by the option name but is useful if\n  you completely trust authors\n* `rehype-raw` can handle the raw embedded HTML strings by parsing them\n  into standard hast nodes (`element`, `text`, etc);\n  this is a heavy task as it needs a full HTML parser,\n  but it is the only way to support untrusted content\n\n###### Footnotes\n\nMany options supported here relate to footnotes.\nFootnotes are not specified by CommonMark,\nwhich we follow by default.\nThey are supported by GitHub,\nso footnotes can be enabled in markdown with `remark-gfm`.\n\nThe options `footnoteBackLabel` and `footnoteLabel` define natural language\nthat explains footnotes,\nwhich is hidden for sighted users but shown to assistive technology.\nWhen your page is not in English,\nyou must define translated values.\n\nBack references use ARIA attributes,\nbut the section label itself uses a heading that is hidden with an\n`sr-only` class.\nTo show it to sighted users,\ndefine different attributes in `footnoteLabelProperties`.\n\n###### Clobbering\n\nFootnotes introduces a problem,\nas it links footnote calls to footnote definitions on the page through `id`\nattributes generated from user content,\nwhich results in DOM clobbering.\n\nDOM clobbering is this:\n\n```html\n<p id=x></p>\n<script>alert(x) // `x` now refers to the DOM `p#x` element</script>\n```\n\nElements by their ID are made available by browsers on the `window` object,\nwhich is a security risk.\nUsing a prefix solves this problem.\n\nMore information on how to handle clobbering and the prefix is explained in\n*Example: headings (DOM clobbering)* in `rehype-sanitize`.\n\n###### Unknown nodes\n\nUnknown nodes are nodes with a type that isnâ€™t in `handlers` or `passThrough`.\nThe default behavior for unknown nodes is:\n\n* when the node has a `value`\n  (and doesnâ€™t have `data.hName`, `data.hProperties`, or `data.hChildren`,\n  see later),\n  create a hast `text` node\n* otherwise,\n  create a `<div>` element (which could be changed with `data.hName`),\n  with its children mapped from mdast to hast as well\n\nThis behavior can be changed by passing an `unknownHandler`.",
          "tags": [
            [
              "overload",
              null
            ],
            [
              "overload",
              null
            ],
            [
              "overload",
              null
            ],
            [
              "param",
              "destination Processor or configuration (optional)."
            ],
            [
              "param",
              "options When a processor was given,\nconfiguration (optional)."
            ],
            [
              "returns",
              "Transform."
            ]
          ],
          "start": 135,
          "length": 12,
          "target": "remarkRehype",
          "line": 3,
          "character": 7
        },
        {
          "type": "hover",
          "text": "(alias) const unified: Processor<undefined, undefined, undefined, undefined, undefined>\nimport unified",
          "docs": "Create a new processor.",
          "tags": [
            [
              "example",
              "  This example shows how a new processor can be created (from `remark`) and linked\n  to **stdin**(4) and **stdout**(4).\n\n  ```js\n  import process from 'node:process'\n  import concatStream from 'concat-stream'\n  import {remark} from 'remark'\n\n  process.stdin.pipe(\n    concatStream(function (buf) {\n      process.stdout.write(String(remark().processSync(buf)))\n    })\n  )\n  ```"
            ],
            [
              "returns",
              "  New *unfrozen* processor (`processor`).\n\n  This processor is configured to work the same as its ancestor.\n  When the descendant processor is configured in the future it does not\n  affect the ancestral processor."
            ]
          ],
          "start": 178,
          "length": 7,
          "target": "unified",
          "line": 4,
          "character": 9
        },
        {
          "type": "hover",
          "text": "const file: VFile",
          "start": 210,
          "length": 4,
          "target": "file",
          "line": 6,
          "character": 6
        },
        {
          "type": "hover",
          "text": "(alias) unified(): Processor<undefined, undefined, undefined, undefined, undefined>\nimport unified",
          "docs": "Create a new processor.",
          "tags": [
            [
              "example",
              "  This example shows how a new processor can be created (from `remark`) and linked\n  to **stdin**(4) and **stdout**(4).\n\n  ```js\n  import process from 'node:process'\n  import concatStream from 'concat-stream'\n  import {remark} from 'remark'\n\n  process.stdin.pipe(\n    concatStream(function (buf) {\n      process.stdout.write(String(remark().processSync(buf)))\n    })\n  )\n  ```"
            ],
            [
              "returns",
              "  New *unfrozen* processor (`processor`).\n\n  This processor is configured to work the same as its ancestor.\n  When the descendant processor is configured in the future it does not\n  affect the ancestral processor."
            ]
          ],
          "start": 223,
          "length": 7,
          "target": "unified",
          "line": 6,
          "character": 19
        },
        {
          "type": "hover",
          "text": "(method) Processor<undefined, undefined, undefined, undefined, undefined>.use<[], string, Root>(plugin: Plugin<[], string, Root>, ...parameters: [] | [boolean]): Processor<Root, undefined, undefined, undefined, undefined> (+2 overloads)",
          "docs": "Configure the processor to use a plugin, a list of usable values, or a\npreset.\n\nIf the processor is already using a plugin, the previous plugin\nconfiguration is changed based on the options that are passed in.\nIn other words, the plugin is not added a second time.\n\n> **Note**: `use` cannot be called on *frozen* processors.\n> Call the processor first to create a new unfrozen processor.",
          "tags": [
            [
              "example",
              "  There are many ways to pass plugins to `.use()`.\n  This example gives an overview:\n\n  ```js\n  import {unified} from 'unified'\n\n  unified()\n    // Plugin with options:\n    .use(pluginA, {x: true, y: true})\n    // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):\n    .use(pluginA, {y: false, z: true})\n    // Plugins:\n    .use([pluginB, pluginC])\n    // Two plugins, the second with options:\n    .use([pluginD, [pluginE, {}]])\n    // Preset with plugins and settings:\n    .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})\n    // Settings only:\n    .use({settings: {position: false}})\n  ```"
            ],
            [
              "template",
              "{Array<unknown>} [Parameters=[]]"
            ],
            [
              "template",
              "{Node | string | undefined} [Input=undefined]"
            ],
            [
              "template",
              "[Output=Input]"
            ],
            [
              "overload",
              null
            ],
            [
              "overload",
              null
            ],
            [
              "overload",
              null
            ],
            [
              "param",
              "value Usable value."
            ],
            [
              "param",
              "parameters Parameters, when a plugin is given as a usable value."
            ],
            [
              "returns",
              "Current processor."
            ]
          ],
          "start": 236,
          "length": 3,
          "target": "use",
          "line": 7,
          "character": 3
        },
        {
          "type": "hover",
          "text": "(alias) const remarkParse: Plugin<[(Readonly<Options> | null | undefined)?], string, Root>\nimport remarkParse",
          "docs": "Add support for parsing from markdown.",
          "tags": [
            [
              "this",
              "  processor."
            ],
            [
              "param",
              "Configuration (optional)."
            ],
            [
              "returns",
              "  Nothing."
            ]
          ],
          "start": 240,
          "length": 11,
          "target": "remarkParse",
          "line": 7,
          "character": 7
        },
        {
          "type": "hover",
          "text": "(method) Processor<Root, undefined, undefined, undefined, undefined>.use<[], Root, Root>(plugin: Plugin<[], Root, Root>, ...parameters: [] | [boolean]): Processor<Root, Root, Root, undefined, undefined> (+2 overloads)",
          "docs": "Configure the processor to use a plugin, a list of usable values, or a\npreset.\n\nIf the processor is already using a plugin, the previous plugin\nconfiguration is changed based on the options that are passed in.\nIn other words, the plugin is not added a second time.\n\n> **Note**: `use` cannot be called on *frozen* processors.\n> Call the processor first to create a new unfrozen processor.",
          "tags": [
            [
              "example",
              "  There are many ways to pass plugins to `.use()`.\n  This example gives an overview:\n\n  ```js\n  import {unified} from 'unified'\n\n  unified()\n    // Plugin with options:\n    .use(pluginA, {x: true, y: true})\n    // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):\n    .use(pluginA, {y: false, z: true})\n    // Plugins:\n    .use([pluginB, pluginC])\n    // Two plugins, the second with options:\n    .use([pluginD, [pluginE, {}]])\n    // Preset with plugins and settings:\n    .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})\n    // Settings only:\n    .use({settings: {position: false}})\n  ```"
            ],
            [
              "template",
              "{Array<unknown>} [Parameters=[]]"
            ],
            [
              "template",
              "{Node | string | undefined} [Input=undefined]"
            ],
            [
              "template",
              "[Output=Input]"
            ],
            [
              "overload",
              null
            ],
            [
              "overload",
              null
            ],
            [
              "overload",
              null
            ],
            [
              "param",
              "value Usable value."
            ],
            [
              "param",
              "parameters Parameters, when a plugin is given as a usable value."
            ],
            [
              "returns",
              "Current processor."
            ]
          ],
          "start": 256,
          "length": 3,
          "target": "use",
          "line": 8,
          "character": 3
        },
        {
          "type": "hover",
          "text": "(alias) function remarkRehype(processor: Processor, options?: Readonly<Options> | null | undefined): TransformBridge (+2 overloads)\nimport remarkRehype",
          "docs": "Turn markdown into HTML.\n\n##### Notes\n\n###### Signature\n\n* if a processor is given,\n  runs the (rehype) plugins used on it with a hast tree,\n  then discards the result (*bridge mode*)\n* otherwise,\n  returns a hast tree,\n  the plugins used after `remarkRehype` are rehype plugins (*mutate mode*)\n\n> ðŸ‘‰ **Note**:\n> Itâ€™s highly unlikely that you want to pass a `processor`.\n\n###### HTML\n\nRaw HTML is available in mdast as `html` nodes and can be embedded in hast\nas semistandard `raw` nodes.\nMost plugins ignore `raw` nodes but two notable ones donâ€™t:\n\n* `rehype-stringify` also has an option `allowDangerousHtml` which will\n  output the raw HTML.\n  This is typically discouraged as noted by the option name but is useful if\n  you completely trust authors\n* `rehype-raw` can handle the raw embedded HTML strings by parsing them\n  into standard hast nodes (`element`, `text`, etc);\n  this is a heavy task as it needs a full HTML parser,\n  but it is the only way to support untrusted content\n\n###### Footnotes\n\nMany options supported here relate to footnotes.\nFootnotes are not specified by CommonMark,\nwhich we follow by default.\nThey are supported by GitHub,\nso footnotes can be enabled in markdown with `remark-gfm`.\n\nThe options `footnoteBackLabel` and `footnoteLabel` define natural language\nthat explains footnotes,\nwhich is hidden for sighted users but shown to assistive technology.\nWhen your page is not in English,\nyou must define translated values.\n\nBack references use ARIA attributes,\nbut the section label itself uses a heading that is hidden with an\n`sr-only` class.\nTo show it to sighted users,\ndefine different attributes in `footnoteLabelProperties`.\n\n###### Clobbering\n\nFootnotes introduces a problem,\nas it links footnote calls to footnote definitions on the page through `id`\nattributes generated from user content,\nwhich results in DOM clobbering.\n\nDOM clobbering is this:\n\n```html\n<p id=x></p>\n<script>alert(x) // `x` now refers to the DOM `p#x` element</script>\n```\n\nElements by their ID are made available by browsers on the `window` object,\nwhich is a security risk.\nUsing a prefix solves this problem.\n\nMore information on how to handle clobbering and the prefix is explained in\n*Example: headings (DOM clobbering)* in `rehype-sanitize`.\n\n###### Unknown nodes\n\nUnknown nodes are nodes with a type that isnâ€™t in `handlers` or `passThrough`.\nThe default behavior for unknown nodes is:\n\n* when the node has a `value`\n  (and doesnâ€™t have `data.hName`, `data.hProperties`, or `data.hChildren`,\n  see later),\n  create a hast `text` node\n* otherwise,\n  create a `<div>` element (which could be changed with `data.hName`),\n  with its children mapped from mdast to hast as well\n\nThis behavior can be changed by passing an `unknownHandler`.",
          "tags": [
            [
              "overload",
              null
            ],
            [
              "overload",
              null
            ],
            [
              "overload",
              null
            ],
            [
              "param",
              "destination Processor or configuration (optional)."
            ],
            [
              "param",
              "options When a processor was given,\nconfiguration (optional)."
            ],
            [
              "returns",
              "Transform."
            ]
          ],
          "start": 260,
          "length": 12,
          "target": "remarkRehype",
          "line": 8,
          "character": 7
        },
        {
          "type": "hover",
          "text": "(method) Processor<Root, Root, Root, undefined, undefined>.use<[RehypeShikiOptions], Root, Root>(plugin: Plugin<[RehypeShikiOptions], Root, Root>, ...parameters: [RehypeShikiOptions] | [boolean]): Processor<Root, Root, Root, undefined, undefined> (+2 overloads)",
          "docs": "Configure the processor to use a plugin, a list of usable values, or a\npreset.\n\nIf the processor is already using a plugin, the previous plugin\nconfiguration is changed based on the options that are passed in.\nIn other words, the plugin is not added a second time.\n\n> **Note**: `use` cannot be called on *frozen* processors.\n> Call the processor first to create a new unfrozen processor.",
          "tags": [
            [
              "example",
              "  There are many ways to pass plugins to `.use()`.\n  This example gives an overview:\n\n  ```js\n  import {unified} from 'unified'\n\n  unified()\n    // Plugin with options:\n    .use(pluginA, {x: true, y: true})\n    // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):\n    .use(pluginA, {y: false, z: true})\n    // Plugins:\n    .use([pluginB, pluginC])\n    // Two plugins, the second with options:\n    .use([pluginD, [pluginE, {}]])\n    // Preset with plugins and settings:\n    .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})\n    // Settings only:\n    .use({settings: {position: false}})\n  ```"
            ],
            [
              "template",
              "{Array<unknown>} [Parameters=[]]"
            ],
            [
              "template",
              "{Node | string | undefined} [Input=undefined]"
            ],
            [
              "template",
              "[Output=Input]"
            ],
            [
              "overload",
              null
            ],
            [
              "overload",
              null
            ],
            [
              "overload",
              null
            ],
            [
              "param",
              "value Usable value."
            ],
            [
              "param",
              "parameters Parameters, when a plugin is given as a usable value."
            ],
            [
              "returns",
              "Current processor."
            ]
          ],
          "start": 277,
          "length": 3,
          "target": "use",
          "line": 9,
          "character": 3
        },
        {
          "type": "hover",
          "text": "(alias) const rehypeShiki: Plugin<[RehypeShikiOptions], Root>\nimport rehypeShiki",
          "start": 281,
          "length": 11,
          "target": "rehypeShiki",
          "line": 9,
          "character": 7
        },
        {
          "type": "hover",
          "text": "(property) RehypeShikiExtraOptions.inline?: false | \"tailing-curly-colon\" | undefined",
          "docs": "Highlight inline code blocks\n\n- `false`: disable inline code block highlighting\n- `tailing-curly-colon`: highlight with `\\`code{:lang}\\``",
          "tags": [
            [
              "see",
              "https://shiki.style/packages/rehype#inline-code"
            ],
            [
              "default",
              "false"
            ]
          ],
          "start": 300,
          "length": 6,
          "target": "inline",
          "line": 10,
          "character": 4
        },
        {
          "type": "hover",
          "text": "(method) Processor<Root, Root, Root, undefined, undefined>.use<[], Root, string>(plugin: Plugin<[], Root, string>, ...parameters: [] | [boolean]): Processor<Root, Root, Root, Root, string> (+2 overloads)",
          "docs": "Configure the processor to use a plugin, a list of usable values, or a\npreset.\n\nIf the processor is already using a plugin, the previous plugin\nconfiguration is changed based on the options that are passed in.\nIn other words, the plugin is not added a second time.\n\n> **Note**: `use` cannot be called on *frozen* processors.\n> Call the processor first to create a new unfrozen processor.",
          "tags": [
            [
              "example",
              "  There are many ways to pass plugins to `.use()`.\n  This example gives an overview:\n\n  ```js\n  import {unified} from 'unified'\n\n  unified()\n    // Plugin with options:\n    .use(pluginA, {x: true, y: true})\n    // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):\n    .use(pluginA, {y: false, z: true})\n    // Plugins:\n    .use([pluginB, pluginC])\n    // Two plugins, the second with options:\n    .use([pluginD, [pluginE, {}]])\n    // Preset with plugins and settings:\n    .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})\n    // Settings only:\n    .use({settings: {position: false}})\n  ```"
            ],
            [
              "template",
              "{Array<unknown>} [Parameters=[]]"
            ],
            [
              "template",
              "{Node | string | undefined} [Input=undefined]"
            ],
            [
              "template",
              "[Output=Input]"
            ],
            [
              "overload",
              null
            ],
            [
              "overload",
              null
            ],
            [
              "overload",
              null
            ],
            [
              "param",
              "value Usable value."
            ],
            [
              "param",
              "parameters Parameters, when a plugin is given as a usable value."
            ],
            [
              "returns",
              "Current processor."
            ]
          ],
          "start": 370,
          "length": 3,
          "target": "use",
          "line": 13,
          "character": 3
        },
        {
          "type": "hover",
          "text": "(alias) const rehypeStringify: Plugin<[(Options | null | undefined)?], Root, string>\nimport rehypeStringify",
          "docs": "Plugin to add support for serializing as HTML.",
          "tags": [
            [
              "this",
              "  processor."
            ],
            [
              "param",
              "Configuration (optional)."
            ],
            [
              "returns",
              "  Nothing."
            ]
          ],
          "start": 374,
          "length": 15,
          "target": "rehypeStringify",
          "line": 13,
          "character": 7
        },
        {
          "type": "hover",
          "text": "(method) Processor<Root, Root, Root, Root, string>.process(file?: Compatible | undefined): Promise<VFile> (+1 overload)",
          "docs": "Process the given file as configured on the processor.\n\n> **Note**: `process` freezes the processor if not already *frozen*.\n\n> **Note**: `process` performs the parse, run, and stringify phases.",
          "tags": [
            [
              "overload",
              null
            ],
            [
              "overload",
              null
            ],
            [
              "param",
              "file File (optional); typically `string` or `VFile`]; any value accepted as\n`x` in `new VFile(x)`."
            ],
            [
              "param",
              "done Callback (optional)."
            ],
            [
              "returns",
              "\nNothing if `done` is given.\nOtherwise a promise, rejected with a fatal error or resolved with the\nprocessed file.\n\nThe parsed, transformed, and compiled value is available at\n`file.value` (see note).\n\n> **Note**: unified typically compiles by serializing: most\n> compilers return `string` (or `Uint8Array`).\n> Some compilers, such as the one configured with\n> [`rehype-react`][rehype-react], return other values (in this case, a\n> React tree).\n> If youâ€™re using a compiler that doesnâ€™t serialize, expect different\n> result values.\n>\n> To register custom results in TypeScript, add them to\n> {@linkcode CompileResultMap}.\n\n[rehype-react]: https://github.com/rehypejs/rehype-react"
            ]
          ],
          "start": 394,
          "length": 7,
          "target": "process",
          "line": 14,
          "character": 3
        },
        {
          "type": "hover",
          "text": "any",
          "start": 408,
          "length": 2,
          "target": "fs",
          "line": 14,
          "character": 17
        },
        {
          "type": "hover",
          "text": "any",
          "start": 411,
          "length": 8,
          "target": "readFile",
          "line": 14,
          "character": 20
        }
      ],
      "code": "import rehypeShiki from '@shikijs/rehype'\nimport rehypeStringify from 'rehype-stringify'\nimport remarkParse from 'remark-parse'\nimport remarkRehype from 'remark-rehype'\nimport { unified } from 'unified'\n\nconst file = await unified()\n  .use(remarkParse)\n  .use(remarkRehype)\n  .use(rehypeShiki, {\n    inline: 'tailing-curly-colon', // or other options\n    // ...\n  })\n  .use(rehypeStringify)\n  .process(await fs.readFile('./input.md'))",
      "meta": {
        "extension": "ts"
      }
    }
  }
}