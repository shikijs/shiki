import fs from 'fs-extra'
import { EmulatedRegExp } from 'oniguruma-to-es'
import { loadLangs } from '../../langs/scripts/langs'
import { precompileGrammar } from './precompile'

export async function prepareLangs() {
  const resolvedLangs = await loadLangs()
  const exportedFileNames: string[] = []

  for (const json of resolvedLangs) {
    const deps: string[] = json.embeddedLangs || []
    const depsStr = [
      ...deps.map(i => `...${i.replace(/\W/g, '_')}`),
      'lang',
    ].join(',\n') || ''

    let precompiledStr: string | undefined
    try {
      const precompiled = precompileGrammar(json)
      precompiledStr = toJsLiteral(precompiled)
    }
    catch (e) {
      console.error(`Failed to precompile ${json.name}: ${e}`)
    }

    await fs.writeFile(
      `./dist/${json.name}.mjs`,
      precompiledStr == null
        ? `export default []

throw new Error("${json.name} is not supported due to the grammar limits")
`
        : `
${precompiledStr.includes('new EmulatedRegExp') ? 'import { EmulatedRegExp } from \'oniguruma-to-es\'' : ''}
${deps.map(i => `import ${i.replace(/\W/g, '_')} from './${i}.mjs'`).join('\n')}

const lang = Object.freeze(${precompiledStr})

export default [\n${depsStr}\n]
`.replace(/\n{2,}/g, '\n\n').trimStart(),
      'utf-8',
    )

    for (const alias of json.aliases || []) {
      if (isInvalidFilename(alias))
        continue
      await fs.writeFile(
        `./dist/${alias}.mjs`,
        `/* Alias ${alias} for ${json.name} */
export { default } from './${json.name}.mjs'
`,
        'utf-8',
      )
    }

    for (const name of [...json.aliases || [], json.name]) {
      if (isInvalidFilename(name))
        continue
      exportedFileNames.push(name)
      await fs.writeFile(
        `./dist/${name}.d.mts`,
        `import type { LanguageRegistration } from '@shikijs/types'
const langs: LanguageRegistration []
export default langs
`,
        'utf-8',
      )
    }
  }

  await fs.writeFile(
    './dist/index.mjs',
    `// Generated by scripts/prepare.ts

export const languageNames = [
${resolvedLangs.map(i => JSON.stringify(i.name)).sort().join(',\n')}
]

export const languageAliasNames = [
${exportedFileNames.filter(i => !resolvedLangs.some(j => j.name === i)).sort().map(i => JSON.stringify(i)).join(',\n')}
]
`,
    'utf-8',
  )

  await fs.writeFile(
    './dist/index.d.mts',
    `
export const languageNames: string[]
export const languageAliasNames: string[]
`,
    'utf-8',
  )

  const packageJson = JSON.parse(await fs.readFile('./package.json', 'utf-8'))
  packageJson.exports = {
    '.': './dist/index.mjs',
    ...Object.fromEntries(
      exportedFileNames.map(i => [
        `./${i}`,
        `./dist/${i}.mjs`,
      ]),
    ),
  }
  await fs.writeFile('./package.json', `${JSON.stringify(packageJson, null, 2)}\n`, 'utf-8')
}

function isInvalidFilename(filename: string) {
  return !filename.match(/^[\w-]+$/)
}

export function toJsLiteral(value: any, seen = new Set()): string {
  // null
  if (value === null) {
    return 'null'
  }

  // undefined
  if (typeof value === 'undefined') {
    return 'undefined'
  }

  // Boolean or number
  if (typeof value === 'boolean' || typeof value === 'number') {
    return String(value)
  }

  if (value instanceof EmulatedRegExp) {
    return `new EmulatedRegExp(${JSON.stringify(value.rawArgs.pattern)},${JSON.stringify(value.rawArgs.flags)},${JSON.stringify(value.rawArgs.options)})`
  }

  // RegExp
  if (value instanceof RegExp) {
    // e.g., /pattern/gi
    return value.toString()
  }

  // String
  if (typeof value === 'string') {
    // Use JSON.stringify for correct escaping
    return JSON.stringify(value)
  }

  // Array
  if (Array.isArray(value)) {
    // Before recursing, check for cycles.
    if (seen.has(value)) {
      throw new Error('Circular reference detected in array')
    }
    seen.add(value)

    const elements = value.map(item => toJsLiteral(item, seen))
    const content = elements.join(',')
    return `[${content}]`
  }

  // Object
  if (typeof value === 'object') {
    // Before recursing, check for cycles.
    if (seen.has(value)) {
      throw new Error('Circular reference detected in object')
    }
    seen.add(value)

    const entries = []
    for (const key of Object.keys(value)) {
      entries.push(`${safeKey(key)}:${toJsLiteral(value[key], seen)}`)
    }
    return `{${entries.join(',')}}`
  }

  // Fallback
  return JSON.stringify(value)
}

/**
 * Safely wraps the key in quotes if it's not a valid JS identifier.
 */
function safeKey(key: string) {
  // A simple check for valid identifier names
  const validIdentifier = /^[a-z_$][\w$]*$/i
  if (validIdentifier.test(key)) {
    return key // leave as is
  }
  // otherwise, wrap in quotes
  return JSON.stringify(key)
}
